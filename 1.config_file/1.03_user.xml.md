## 1.3 user.xml 配置

### 1.3.1 整体XML结构
   
+ managerUser (可多值,至少一个)
+ shardingUser (可多值)
+ rwSplitUser (可多值)
+ analysisUser (可多值)
+ hybridTAUser (可多值)
+ blacklist(可多值)

配置注意事项：
1. 当user.xml文件中不配置shardingUser，dble不再加载sharding.xml配置文件(即dble不具备分表分库)，包括集群情况下出现sharding.xml不一致，均属于已知现象。  

### 1.3.2 managerUser(管理用户配置)

<table >
<tbody>
<tr>
<td  ><p><strong>配置名称</strong></p></td>
<td  ><p><strong>配置内容</strong></p></td>
<td  ><p><strong>可选项/默认值</strong></p></td>
<td  ><p><strong>详细作用原理或应用</strong></p></td>
</tr>
<tr>
<td  ><p>name</p></td>
<td  ><p>用户名</p></td>
<td  ><p>符合mysql用户名规范的字符串</p></td>
<td  ><p>用户唯一标识，用于登录校验</p></td>
</tr>
<tr>
<td  ><p>password</p></td>
<td  ><p>密码</p></td>
<td  ></td>
<td  ><p>用户密码校验</p></td>
</tr>
<tr>
<td  ><p>usingDecrypt</p></td>
<td  ><p>是否启用加密</p></td>
<td  ><p>可配置true/false，默认false</p></td>
<td  ><p>
启用加密password项配置通过执行脚本encrypt.sh 0:{user}:{password}的结果进行配置</br>
举例：</br>
encrypt.sh 0:xxx:123456</br>
fP/nl3XPXrSfWjpQzit5lIOrRU1QRXuLTYtATUG0fGW2k5kdXUhKL5zf02hE6nGjdnSWrufVkJPUZpbQ2qX9uQ==</br>
配置项：</br>
password fP/nl3XPXrSfWjpQzit5lIOrRU1QRXuLTYtATUG0fGW2k5kdXUhKL5zf02hE6nGjdnSWrufVkJPUZpbQ2qX9uQ==</br>
user xxx</br>
登录项：</br>
-u xxx -p123456</br>
</p></td>
</tr>
<tr>
<td  ><p>whiteIPs</p></td>
<td  ><p>可登录的ip的白名单</p></td>
<td  ><p>可选项</p></td>
<td  ><p>可以参考本配置文件中的whiteIPs内容</p></td>
</tr>
<tr>
<td  ><p>readOnly</p></td>
<td  ><p>是否是只读管理用户</p></td>
<td  ><p>可配置true/false，默认false</p></td>
<td  ><p>只读用户不能进行运维管理操作，只能进行show或者select</p></td>
</tr>
<tr>
<td  ><p>maxCon</p></td>
<td  ><p>负载限制，默认不做限制</p></td>
<td  ><p>正整数</p></td>
<td  ><p>用户的连接数限制,会在用户验证登录的时候进行校验，默认0，表示不做限制。 特别的，管理用户不受系统级别的maxCon的限制</p></td>
</tr>
</tbody>
</table>

### 1.3.3 shardingUser(分库用户配置) 

<table >
<tbody>
<tr>
<td  ><p><strong>配置名称</strong></p></td>
<td  ><p><strong>配置内容</strong></p></td>
<td  ><p><strong>可选项/默认值</strong></p></td>
<td  ><p><strong>详细作用原理或应用</strong></p></td>
</tr>
<tr>
<td  ><p>name</p></td>
<td  ><p>用户名</p></td>
<td  ><p>符合mysql用户名规范的字符串</p></td>
<td  ><p>用户唯一标识，用于登录校验</p></td>
</tr>
<tr>
<td  ><p>password</p></td>
<td  ><p>密码</p></td>
<td  ></td>
<td  ><p>用户密码校验</p></td>
</tr>
<tr>
<td  ><p>usingDecrypt</p></td>
<td  ><p>是否启用加密</p></td>
<td  ><p>可配置true/false，默认false</p></td>
<td  ><p>
启用加密password项配置通过执行脚本encrypt.sh 0:{user}:{password}的结果进行配置</br>
举例：</br>
encrypt.sh 0:xxx:123456</br>
fP/nl3XPXrSfWjpQzit5lIOrRU1QRXuLTYtATUG0fGW2k5kdXUhKL5zf02hE6nGjdnSWrufVkJPUZpbQ2qX9uQ==</br>
配置项：</br>
password fP/nl3XPXrSfWjpQzit5lIOrRU1QRXuLTYtATUG0fGW2k5kdXUhKL5zf02hE6nGjdnSWrufVkJPUZpbQ2qX9uQ==</br>
user xxx</br>
登录项：</br>
-u xxx -p123456</br>
</p></td>
</tr>
<tr>
<td  ><p>whiteIPs</p></td>
<td  ><p>可登录的ip的白名单</p></td>
<td  ><p>可选项</p></td>
<td  ><p>可以参考本配置文件中的whiteIPs内容</p></td>
</tr>
<tr>
<td  ><p>readOnly</p></td>
<td  ><p>是否是只读分库用户</p></td>
<td  ><p>可配置true/false，默认false</p></td>
<td  ><p>只读用户不能进行DML操作，只能进行show或者select</p></td>
</tr>
<tr>
<td  ><p>tenant</p></td>
<td  ><p>租户名</p></td>
<td  ><p>可选配置。和用户名相当于整个用户列表的联合主键</p></td>
<td  >可以参考本配置文件中的tenant内容</td>
</tr>
<tr>
<td  ><p>schemas</p></td>
<td  ><p>该用户可以访问的schema列表</p></td>
<td  ><p>可配置多值，用逗号隔开</p></td>
<td  ><p>该用户可以访问的schema列表，schema参见sharding.xml中的schma名称</p></td>
</tr>
<tr>
<td  ><p>maxCon</p></td>
<td  ><p>负载限制，默认不做限制</p></td>
<td  ><p>正整数</p></td>
<td  ><p>用户的连接数限制,会在用户验证登录的时候进行校验，默认0，表示不做限制。 特别的，当系统级别的maxCon已经到达上限之后，本用户的maxCon会失效，不能新建连接</p></td>
</tr>
<tr>
<td  ><p>blacklist</p></td>
<td  ><p>blacklist的名称</p></td>
<td  ><p>可选配置</p></td>
<td  ><p>可以参考本配置文件中的blacklist内容</p></td>
</tr>
<tr>
<td  ><p>privileges</p></td>
<td  ><p>子元素，具体table的增删改查权限</p></td>
<td  ><p>可选配置</p></td>
<td  ><p>可以参考本配置文件中的privileges内容</p></td>
</tr>
</tbody>
</table>

#### 1.3.3.1 user.privileges.schema 

user.privileges 下的schema的dml权限，可配置多值

<table >
<tbody>
<tr>
<td  ><br>
<p><strong>配置名称</strong></p><br></td>
<td  ><br>
<p><strong>配置内容</strong></p><br></td>
<td  ><br>
<p><strong>可选项/默认值</strong></p><br></td>
<td  ><br>
<p><strong>详细作用原理或应用</strong></p><br></td>
</tr>
<tr>
<td  ><br>
<p>name</p><br></td>
<td  ><br>
<p>schema名称</p><br></td>
<td  ></td>
<td  ><br>
<p>用以标识对应schema</p><br></td>
</tr>
<tr>
<td  ><br>
<p>dml</p><br></td>
<td  ><br>
<p>dml权限</p><br></td>
<td  ><br>
<p>0000</p><br></td>
<td  ><br>
<p>权限判断，每一位分别表示INSERT UPDATE SELECT DELETE四种权限</p><br>
<p>1- 拥有权限 0-没有权限 例如拥有所有权限为1111</p></td>
</tr>
<tr>
<td  ><br>
<p><strong>table</strong></p><br></td>
<td  >
<p>子元素</p><br></td>
<td  >
<p>可配置多个</p><br></td>
<td  ><br>
<p>如果没有配置，则table继承schema的权限</p><br></td>
</tr>
</tbody>
</table>

#### 1.3.3.2 user.privileges.schema.table

<table>
<tbody>
<tr>
<td  ><br>
<p><strong>配置名称</strong></p><br></td>
<td  ><br>
<p><strong>配置内容</strong></p><br></td>
<td  ><br>
<p><strong>可选项/默认值</strong></p><br></td>
<td  ><br>
<p><strong>详细作用原理或应用</strong></p><br></td>
</tr>
<tr>
<td  ><br>
<p>name</p><br></td>
<td  ><br>
<p>表格名称</p><br></td>
<td  ><br>
<p></p><br></td>
<td  ><br>
<p>在权限判断的时候作为key值</p><br></td>
</tr>
<tr>
<td  ><br>
<p>dml</p><br></td>
<td  ><br>
<p>dml权限</p><br></td>
<td  ><br>
<p>0000</p><br></td>
<td  ><br>
<p>权限判断，每一位分别表示INSERT UPDATE SELECT DELETE四种权限</p><br>
<p>1- 拥有权限 0-没有权限 例如拥有所有权限为1111</p></td>
</tr>
</tbody>
</table>

### 1.3.4 rwSplitUser(读写用户配置) 


<table >
<tbody>
<tr>
<td  ><p><strong>配置名称</strong></p></td>
<td  ><p><strong>配置内容</strong></p></td>
<td  ><p><strong>可选项/默认值</strong></p></td>
<td  ><p><strong>详细作用原理或应用</strong></p></td>
</tr>
<tr>
<td  ><p>name</p></td>
<td  ><p>用户名</p></td>
<td  ><p>符合mysql用户名规范的字符串</p></td>
<td  ><p>用户唯一标识，用于登录校验</p></td>
</tr>
<tr>
<td  ><p>password</p></td>
<td  ><p>密码</p></td>
<td  ></td>
<td  ><p>用户密码校验</p></td>
</tr>
<tr>
<td  ><p>usingDecrypt</p></td>
<td  ><p>是否启用加密</p></td>
<td  ><p>可配置true/false，默认false</p></td>
<td  ><p>
启用加密password项配置通过执行脚本encrypt.sh 0:{user}:{password}的结果进行配置</br>
举例：</br>
encrypt.sh 0:xxx:123456</br>
fP/nl3XPXrSfWjpQzit5lIOrRU1QRXuLTYtATUG0fGW2k5kdXUhKL5zf02hE6nGjdnSWrufVkJPUZpbQ2qX9uQ==</br>
配置项：</br>
password fP/nl3XPXrSfWjpQzit5lIOrRU1QRXuLTYtATUG0fGW2k5kdXUhKL5zf02hE6nGjdnSWrufVkJPUZpbQ2qX9uQ==</br>
user xxx</br>
登录项：</br>
-u xxx -p123456</br>
</p></td>
</tr>
<tr>
<td  ><p>whiteIPs</p></td>
<td  ><p>可登录的ip的白名单</p></td>
<td  ><p>可选项</p></td>
<td  ><p>可以参考本配置文件中的whiteIPs内容</p></td>
</tr>
<tr>
<td  ><p>tenant</p></td>
<td  ><p>租户名</p></td>
<td  ><p>可选配置。和用户名相当于整个用户列表的联合主键</p></td>
<td  ><p>可以参考本配置文件中的tenant内容</p></td>
</tr>
<tr>
<td  ><p>dbGroup</p></td>
<td  ><p>该用户对应的数据库组dbGroup</p></td>
<td  ><p>单值配置</p></td>
<td  ><p>对应db.xml中的dbGroup名称</p></td>
</tr>
<tr>
<td  ><p>maxCon</p></td>
<td  ><p>负载限制，默认不做限制</p></td>
<td  ><p>正整数</p></td>
<td  ><p>用户的连接数限制,会在用户验证登录的时候进行校验，默认0，表示不做限制。 特别的，当系统级别的maxCon已经到达上限之后，本用户的maxCon会失效，不能新建连接</p></td>
</tr>
<tr>
<td  ><p>blacklist</p></td>
<td  ><p>blacklist的名称</p></td>
<td  ><p>可选配置</p></td>
<td  ><p>可以参考本配置文件中的blacklist内容</p></td>
</tr>
</tbody>
</table>

### 1.3.5 analysisUser(分析用户配置)


<table >
<tbody>
<tr>
<td  ><p><strong>配置名称</strong></p></td>
<td  ><p><strong>配置内容</strong></p></td>
<td  ><p><strong>可选项/默认值</strong></p></td>
<td  ><p><strong>详细作用原理或应用</strong></p></td>
</tr>
<tr>
<td  ><p>name</p></td>
<td  ><p>用户名</p></td>
<td  ><p>符合分析数据库用户名规范的字符串（目前支持clickhouse）</p></td>
<td  ><p>用户唯一标识，用于登录校验</p></td>
</tr>
<tr>
<td  ><p>password</p></td>
<td  ><p>密码</p></td>
<td  ></td>
<td  ><p>用户密码校验</p></td>
</tr>
<tr>
<td  ><p>usingDecrypt</p></td>
<td  ><p>是否启用加密</p></td>
<td  ><p>可配置true/false，默认false</p></td>
<td  ><p>
启用加密password项配置通过执行脚本encrypt.sh 0:{user}:{password}的结果进行配置</br>
举例：</br>
encrypt.sh 0:xxx:123456</br>
fP/nl3XPXrSfWjpQzit5lIOrRU1QRXuLTYtATUG0fGW2k5kdXUhKL5zf02hE6nGjdnSWrufVkJPUZpbQ2qX9uQ==</br>
配置项：</br>
password fP/nl3XPXrSfWjpQzit5lIOrRU1QRXuLTYtATUG0fGW2k5kdXUhKL5zf02hE6nGjdnSWrufVkJPUZpbQ2qX9uQ==</br>
user xxx</br>
登录项：</br>
-u xxx -p123456</br>
</p></td>
</tr>
<tr>
<td  ><p>whiteIPs</p></td>
<td  ><p>可登录的ip的白名单</p></td>
<td  ><p>可选项</p></td>
<td  ><p>可以参考本配置文件中的whiteIPs内容</p></td>
</tr>
<tr>
<td  ><p>tenant</p></td>
<td  ><p>租户名</p></td>
<td  ><p>可选配置。和用户名相当于整个用户列表的联合主键</p></td>
<td  ><p>可以参考本配置文件中的tenant内容</p></td>
</tr>
<tr>
<td  ><p>dbGroup</p></td>
<td  ><p>该用户对应的数据库组dbGroup</p></td>
<td  ><p>单值配置</p></td>
<td  ><p>对应db.xml中的dbGroup名称；<br> 注意：这里的dbGroup可以与hybridTAUser的apNode共用同一个</p></td>
</tr>
<tr>
<td  ><p>maxCon</p></td>
<td  ><p>负载限制，默认不做限制</p></td>
<td  ><p>正整数</p></td>
<td  ><p>用户的连接数限制,会在用户验证登录的时候进行校验，默认0，表示不做限制。 特别的，当系统级别的maxCon已经到达上限之后，本用户的maxCon会失效，不能新建连接</p></td>
</tr>
<tr>
<td  ><p>blacklist</p></td>
<td  ><p>blacklist的名称</p></td>
<td  ><p>可选配置</p></td>
<td  ><p>可以参考本配置文件中的blacklist内容</p></td>
</tr>
</tbody>
</table>

### 1.3.6 hybridTAUser(HTAP用户配置)
+ 可参考 [HTAP 快速上手指南](../2.Function/2.39_HTAP.md)
<table >
<tbody>
<tr>
<td  ><p><strong>配置名称</strong></p></td>
<td  ><p><strong>配置内容</strong></p></td>
<td  ><p><strong>可选项/默认值</strong></p></td>
<td  ><p><strong>详细作用原理或应用</strong></p></td>
</tr>
<tr>
<td  ><p>name</p></td>
<td  ><p>用户名</p></td>
<td  ><p>符合mysql用户名规范的字符串</p></td>
<td  ><p>用户唯一标识，用于登录校验</p></td>
</tr>
<tr>
<td  ><p>password</p></td>
<td  ><p>密码</p></td>
<td  ></td>
<td  ><p>用户密码校验</p></td>
</tr>
<tr>
<td  ><p>usingDecrypt</p></td>
<td  ><p>是否启用加密</p></td>
<td  ><p>可配置true/false，默认false</p></td>
<td  ><p>
启用加密password项配置通过执行脚本encrypt.sh 0:{user}:{password}的结果进行配置</br>
举例：</br>
encrypt.sh 0:xxx:123456</br>
fP/nl3XPXrSfWjpQzit5lIOrRU1QRXuLTYtATUG0fGW2k5kdXUhKL5zf02hE6nGjdnSWrufVkJPUZpbQ2qX9uQ==</br>
配置项：</br>
password fP/nl3XPXrSfWjpQzit5lIOrRU1QRXuLTYtATUG0fGW2k5kdXUhKL5zf02hE6nGjdnSWrufVkJPUZpbQ2qX9uQ==</br>
user xxx</br>
登录项：</br>
-u xxx -p123456</br>
</p></td>
</tr>
<tr>
<td  ><p>whiteIPs</p></td>
<td  ><p>可登录的ip的白名单</p></td>
<td  ><p>可选项</p></td>
<td  ><p>可以参考本配置文件中的whiteIPs内容</p></td>
</tr>
<tr>
<td  ><p>readOnly</p></td>
<td  ><p>是否是只读分库用户</p></td>
<td  ><p>可配置true/false，默认false</p></td>
<td  ><p>只读用户不能进行DML操作，只能进行show或者select</p></td>
</tr>
<tr>
<td  ><p>tenant</p></td>
<td  ><p>租户名</p></td>
<td  ><p>可选配置。和用户名相当于整个用户列表的联合主键</p></td>
<td  >可以参考本配置文件中的tenant内容</td>
</tr>
<tr>
<td  ><p>schemas</p></td>
<td  ><p>该用户可以访问的schema列表</p></td>
<td  ><p>可配置多值，用逗号隔开</p></td>
<td  ><p>该用户可以访问的schema列表，schema参见sharding.xml中的schma名称 <br> 注意：对应的dbGroup的databaseType必须是clickhouse</p></td>
</tr>
<tr>
<td  ><p>maxCon</p></td>
<td  ><p>负载限制，默认不做限制</p></td>
<td  ><p>正整数</p></td>
<td  ><p>用户的连接数限制,会在用户验证登录的时候进行校验，默认0，表示不做限制。 特别的，当系统级别的maxCon已经到达上限之后，本用户的maxCon会失效，不能新建连接</p></td>
</tr>
<tr>
<td  ><p>blacklist</p></td>
<td  ><p>blacklist的名称</p></td>
<td  ><p>可选配置</p></td>
<td  ><p>可以参考本配置文件中的blacklist内容</p></td>
</tr>
<tr>
<td  ><p>privileges</p></td>
<td  ><p>子元素，具体table的增删改查权限</p></td>
<td  ><p>可选配置</p></td>
<td  ><p>可以参考本配置文件中的privileges内容</p></td>
</tr>
</tbody>
</table>

### 1.3.7 blacklist(黑名单配置)

<table>
<tbody>
<tr>
<th>配置名称</th>
<th><strong>配置内容</strong></th>
<th>配置范围/可选项</th>
<th><strong>详细作用原理或应用</strong></th>
</tr>
<tr>
<td> name
</td>
<td  >blacklist的名称</td>
<td  ></td>
<td  > <p>用于被用户引用，标记黑名单</p></td>
</tr>
<tr>
<td>
property
</td>
<td  >
子元素，可以有多个
</td>
<td >详细的黑名单校验规则</td>
<td >如果开启黑名单校验具体的校验规则将有
所有property来确定
</tr>
</tbody>
</table>

#### 1.3.7.1  blacklist.property(详细的黑名单配置)

形式为  

```  
<property name="selectHavingAlwayTrueCheck">true</property>

```  

下面表格来描述key和value的含义。



- 解析判断

<table >
<tr >
<th >
<div><sub>配置名称</sub></div>
</th>
<th >
<div><strong><sub>描述</sub></strong></div>
</th>
<th >
<div><strong><sub>默认值</sub></strong></div>
</th>
<th >
<div><strong><sub>可选项</sub></strong></div>
</th>
<th >
<div><strong><sub>详细作用原理或应用</sub></strong></div>
</th>
<th >
<div><strong><sub>分库分表支持程度</sub></strong></div>
</th>
<th >
<div><sub>读写分离支持程度</sub></div>
</th>
</tr>
<tbody >useAllow
<tr>
<td><sub><pre>multiStatementAllow</pre></sub></td>
<td><sub>是否允许一次执行多条语句</sub></td>
<td><sub>false</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>sql数 >1，
值为true时，允许执行多条语句。值为false时，不允许执行多条语句。
由于dble是个中间件，在协议解析层面已经处理过多语句了，所以这个黑名单的配置在Dble下不生效。多语句开关根据应用需要驱动自行设置
</sub></p></td>
<td><sub>不支持</sub></td>
<td><sub>不支持</sub></td>
</tr>
</tbody>
</table>
- sql类型判断  
<table >
<tr >
<th >
<div><sub>配置名称</sub></div>
</th>
<th >
<div><strong><sub>描述</sub></strong></div>
</th>
<th >
<div><strong><sub>默认值</sub></strong></div>
</th>
<th >
<div><strong><sub>可选项</sub></strong></div>
</th>
<th >
<div><strong><sub>详细作用原理或应用</sub></strong></div>
</th>
<th >
<div><strong><sub>命中黑名单sql样例</sub></strong></div>
</th>
<th >
<div><strong><sub>分库分表支持程度</sub></strong></div>
</th>
<th >
<div><sub>读写分离支持程度</sub></div>
</th>
</tr>
<tbody >
<tr>
<td><sub><pre>insertAllow</pre></sub></td>
<td><sub>是否允许执行INSERT语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许执行INSERT语句。值为false时，不允许执行INSERT语句
</sub></p></td>
<td><sub> insert into t1 valut1 values(4,5);</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>deleteAllow</pre></sub></td>
<td><sub>是否允许执行DELETE语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许执行DELETE语句。值为false时，不允许执行DELETE语句
</sub></p></td>
<td><sub>delete from t1;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>updateAllow</pre></sub></td>
<td><sub>是否允许执行UPDATE语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许执行UPDATE语句。值为false时，不允许执行UPDATE语句
</sub></p></td>
<td><sub>update t1 set id = 1 where id =10;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>mergeAllow</pre></sub></td>
<td><sub>是否允许执行merge语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许允许执行merge语句。值为false时，不允许允许执行merge语句
</sub></p></td>
<td><sub> insert into t1 valut1 values(4,5);</sub></td>
<td><sub>mysql不支持该语法,无意义</sub></td>
<td><sub>mysql不支持该语法,无意义</sub></td>
</tr>
<tr>
<td><sub><pre>callAllow</pre></sub></td>
<td><sub>是否允许执行call语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许执行call语句。值为false时，不允许执行call语句
</sub></p></td>
<td><sub>call proc_arc(1);</sub></td>
<td><p><sub>支持，分库分表的存储过程默认需要带hint ，详见 https://actiontech.github.io/dble-docs-cn/3.SQL_Syntax/3.6_procedure_support.html</sub></p></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>truncateAllow</pre></sub></td>
<td><sub>是否允许执行Truncate语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许执行Truncate语句。值为false时，不允许执行Truncate语句
</sub></p></td>
<td><sub>truncate table t1;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>createTableAllow</pre></sub></td>
<td><sub>是否允许创建表</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许创建表。值为false时，不允许创建表
</sub></p></td>
<td><sub> create table  t1(id int, age int);</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>renameTableAllow</pre></sub></td>
<td><sub>是否允许执行Rename语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许执行Rename语句。值为false时，不允许执行Rename语句
</sub></p></td>
<td><sub>rename table t1 to t4;</sub></td>
<td><sub>不支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>alterTableAllow</pre></sub></td>
<td><sub>是否允许执行Alter Table语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
注意：类似ALTER TABLE t1 RENAME t6 的sql会被替换成renam t1 to t6,属于RenameTableAllow控制
值为true时，允许执行Alter Table语句。值为false时，不允许执行Alter Table语句
</sub></p></td>
<td><sub> alter table t1 add d timestamp;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>dropTableAllow</pre></sub></td>
<td><sub>是否允许执行DropTable语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许执行DropTable语句。值为false时，不允许执行DropTable语句
</sub></p></td>
<td><sub>drop table t1;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>setAllow</pre></sub></td>
<td><sub>是否允许执行Set语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许执行Set语句。值为false时，不允许执行Set语句
</sub></p></td>
<td><sub> set @name = 1;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>replaceAllow</pre></sub></td>
<td><sub>是否允许执行Replace语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许执行Replace语句。值为false时，不允许执行执行Replace语句
</sub></p></td>
<td><sub> replace into t1 values (1, 1);</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>describeAllow</pre></sub></td>
<td><sub>是否允许执行describe语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许执行describe语句。值为false时，不允许执行describe语句
</sub></p></td>
<td><sub> describe t1 id;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>showAllow</pre></sub></td>
<td><sub>是否允许执行show语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许执行show语句。值为false时，不允许执行show语句
</sub></p></td>
<td><sub> show columns from t1;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>commitAllow</pre></sub></td>
<td><sub>是否允许执行Commit语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许执行Commit语句。值为false时，不允许执行Commit语句
</sub></p></td>
<td><sub> commit;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>rollbackAllow</pre></sub></td>
<td><sub>是否允许执行Rollback语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许执行Rollback语句。值为false时，不允许执行Rollback语句
</sub></p></td>
<td><sub> rollback;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>useAllow</pre></sub></td>
<td><sub>是否允许执行Use语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许执行Use语句。值为false时，不允许执行Use语句
</sub></p></td>
<td><sub> use db1;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>hintAllow</pre></sub></td>
<td><sub>是否允许执行Hint语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许执行Hint语句。值为false时，不允许执行Hint语句
</sub></p></td>
<td><sub> select * from t1/*!TEMPORARY */;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>lockTableAllow</pre></sub></td>
<td><sub>是否允许执行LockTable语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许执行LockTable语句。值为false时，不允许执行LockTable语句
</sub></p></td>
<td><sub> lock table t1 write;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>startTransactionAllow</pre></sub></td>
<td><sub>是否允许执行StartTransaction语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许执行StartTransaction语句。值为false时，不允许执行StartTransaction语句
</sub></p></td>
<td><sub>start transaction;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>blockAllow</pre></sub></td>
<td><sub>是否允许语句块</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许执行LockTable语句。值为false时，不允许执行LockTable语句
</sub></p></td>
<td><sub> 
begin  
select * from t1 where id=1end;  
</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>noneBaseStatementAllow</pre></sub></td>
<td><sub>是否允许非以上基本语句的其他语句，通过这个选项就能够屏蔽DDL</sub></td>
<td><sub>false</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，不允许以上基本语句的其他语句。值为false时，允许执行以上基本语句的其他语句
</sub></p></td>
<td><sub></sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
</tbody>
</table>

- sql组成元素判断  
  说明：组成元素用expr代替 ，另外未做特殊声明如果判断条件中有多个条件默认为并列都需要满足 除非对以下内容有足够深的了解，否则不建议使用，保持默认值即可

1.常规设置
<table >
<tr >
<th >
<div><sub>配置名称</sub></div>
</th>
<th >
<div><strong><sub>描述</sub></strong></div>
</th>
<th >
<div><strong><sub>默认值</sub></strong></div>
</th>
<th >
<div><strong><sub>可选项</sub></strong></div>
</th>
<th >
<div><strong><sub>详细作用原理或应用</sub></strong></div>
</th>
<th >
<div><strong><sub>命中黑名单sql样例</sub></strong></div>
</th>
<th >
<div><strong><sub>分库分表支持程度</sub></strong></div>
</th>
<th >
<div><sub>读写分离支持程度</sub></div>
</th>
</tr>
<tbody >
<tr>
<td><sub><pre>mustParameterized</pre></sub></td>
<td><sub>含有where条件时，是否必须参数化</sub></td>
<td><sub>false</sub></td>
<td><p><sub>true</sub></p><p><sub>false</sub></p></td>
<td><p><sub> 
如果为True，则不允许类似WHERE ID = 1这种不参数化的SQL</sub></p>
<p><sub> 例如 </sub></p>
<p><sub> 1.select * from t1 inner join t3 on t1.id = 1; 没有where条件，不受规则控制  </sub></p>
<p><sub> 值为true时，不允许不参数化的SQL 。值为false时，允许不参数化的SQL</sub></p>
</td>
<td><sub>select * from t1 where t1.id =1;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>constArithmeticAllow</pre></sub></td>
<td><sub>拦截常量运算的条件</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub> 
值为true时，允许执行常量运算的条件。值为false时，不允许执行常量运算的条件
</sub></p></td>
<td><sub>
<p><sub>select * from t1 where 1>1; </sub></p> 
<p><sub>select * from t1 where id = 3-1;</sub></p>
<p><sub>select * from t1 where true & false;</sub></p>  
</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>limitZeroAllow</pre></sub></td>
<td><sub>是否允许limit 0这样的语句</sub></td>
<td><sub>false</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub> 
值为true时，允许执行limit 0这样的语句。值为false时，不允许执行limit 0这样的语句
</sub></p></td>
<td><sub>select * from t1 limit 0;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>selectAllow</pre></sub></td>
<td><sub>是否允许执行SELECT语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub> 
值为true时，允许执行SELECT语句。值为false时，不允许执行SELECT语句
（与使用方面无关的tips:这个判断正常应该放在sql类型判断的代码逻辑中，druid把它放在了sql组成元素判断） 
</sub></p></td>
<td><sub>select id from t1;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>selectAllColumnAllow</pre></sub></td>
<td><sub>是否允许查询所有列</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub> 
需要满足以下条件</sub></p>
<p><sub>    
1.expr 属于SQLAllColumnExpr类型  
</sub></p>
<p><sub> 
2.expr所在的sql是select类型  
</sub></p>
<p><sub> 
3.所在sql的from中的表为普通单表  
</sub></p>
<p><sub> 
4.不带有别名(x.*)
</sub></p>
举例：
<p><sub>1.select t.* from t1 t; 不属于SQLAllColumnExpr类型，所以不符合该规则，不受黑名单控制 </sub></p> 
<p><sub>2.select * from t1，t3; from后面的表是一个结果集，所以不符合该规则，不受黑名单控制  </sub></p>
<p><sub>3.select * from t1 inner join t3; from后面的表是一个结果集，所以不符合该规则，不受黑名单控制 </sub></p> 
<p><sub> 
值为true时，允许查询所有列。值为false时，不允许查询所有列
</sub></p>
</td>
<td><sub>select * from t1;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>commentAllow</pre></sub></td>
<td><sub>是否允许语句中存在注释</sub></td>
<td><sub>false</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub> 
值为true时，允许语句中存在注释。值为false时，不允许语句中存在注释
</sub></p></td>
<td><sub>
select * from t1 where id =1 or 1=1 /*dble:sql=select 1 from account */;
</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>conditionOpXorAllow</pre></sub></td>
<td><sub>查询条件(where或having)中是否允许有XOR条件</sub></td>
<td><sub>false</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub> 
特例：
</sub></p>
<p><sub> 
select * from t1 inner join t3 on t1.id =(1 xor 1); 没有where 或者having，不受规则控制  
</sub></p>
<p><sub>
值为true时，允许查询条件(where或having)中有XOR条件。值为false时，不允许查询条件(where或having)中有XOR条件
</sub></p></td>
<td><sub>
select * from t1 where id = (1 xor 1);
select * from t1 having id = (1 xor 1);
</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>conditionOpBitwseAllow</pre></sub></td>
<td><sub>查询条件中是否允许有"&"、"~"、"|"、"^"运算符</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub> 
值为true时，允许查询条件中是否允许有"&"、"~"、"|"、"^"运算符。值为false时，不允许查询条件中是否允许有"&"、"~"、"|"、"^"运算符
</sub></p></td>
<td>
<p><sub>select * from t1 where id = (1 & 1); </sub></p>
<p><sub>select * from t1 where id = (1 & select id from t1 limit1); </sub></p>
<p><sub>select * from t1 where id = (1 ^ 1);  </sub></p>
<p><sub>select * from t1 where id = (1 ~ 1); </sub></p>
<p><sub>select * from t1 where id = (1 | 1); </sub></p>
</td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>conditionDoubleConstAllow</pre></sub></td>
<td><sub>查询条件中是否允许连续两个常量运算表达式</sub></td>
<td><sub>false</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>  
必须是and两侧表达式为恒真或者恒假的表达式
</sub></p>
<p><sub> 
举例：
</sub></p>
<p><sub> 
select *from t1 where 3=1 or 3=3; 不是在and两侧，不受规则控制 
</sub></p>
<p><sub> 
值为true时，允许连续两个常量运算表达式。值为false时，不允许连续两个常量运算表达式
</sub></p></td>
<td>
<p><sub>select *from t1 where 3=1 and 3=3;  </sub></p>
<p><sub>select *from t1 where 3=1 or (1=1 and 3=3);  </sub></p>
<p><sub>select *from t1 where 3=1 and (1=1 and 3=3);  </sub></p>
<p><sub>select * from t3 where 1=1 and k like '%';（需要开启conditionLikeTrueAllow 为false）  </sub></p>
<p><sub>select * from t3 where 1=1 and 1= (select count(*) from t1 limit1);  </sub></p>
<p><sub>select * from t3 where 2=1 and true = true;</sub></p>
<p><sub>select * from t3 where id =1 and true = true or id =1 or(1=1 and id =2);  </sub></p>
</td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>deleteWhereNoneCheck</pre></sub></td>
<td><sub>检查DELETE语句是否无where条件</sub></td>
<td><sub>false</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub> 需满足以下条件</sub></p>
<p><sub>  
1.sql没有where条件  
</sub></p>
<p><sub>  
2.没有using  
</sub></p>
<p><sub>  
3.from 的表为普通单表 
</sub></p>
<p><sub> 
举例： 
</sub></p>
<p><sub> delete from t1 using t1 inner join t2; 使用using，导致条件不满足，所以不符合该规则，不受黑名单控制  </sub></p>
<p><sub> delete t1,t2 from t1 left join t2 on t1.id=t2.id; from 的表是一个结果集，所以不符合该规则，不受黑名单控制  </sub></p>
<p><sub>
值为true时，不允许语句中无where条件。值为false时，允许语句中无where条件
</sub></p></td>
<td><sub>
<p><sub>delete from t1;  </sub></p>
<p><sub>delete t1 from t1 left join t2 on t1.id=t2.id;  </sub></p>
</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>updateWhereNoneCheck</pre></sub></td>
<td><sub>检查UPDATE语句是否无where条件</sub></td>
<td><sub>false</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub> 需满足以下条件</sub></p>
<p><sub>
1.没有limit  
</sub></p>
<p><sub>
举例：
</sub></p>
<p><sub>1.update t1 set idd =1 limit 1;有limit条件，所以不符合该规则，不受黑名单控制  </sub></p>
<p><sub>值为true时，不允许语句无where条件。值为false时，允许语句中无where条件
</sub></p></td>
<td><sub>
update t1 set idd =1 ;
</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>conditionAndAlwayFalseAllow</pre></sub></td>
<td><sub>检查查询条件(WHERE/HAVING子句)中是否包含AND永假条件</sub></td>
<td><sub>false</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub> 
值为true时，允许语句中查询条件(WHERE/HAVING子句)中包含AND永假条件。值为false时，不允许语句中查询条件(WHERE/HAVING子句)中包含AND永假条件
</sub></p></td>
<td>
<p><sub>select * from t1  where id = 567 and 2 = 1;</sub></p>
<p><sub>select * from t1 having id =1 and 2=1;  </sub></p>
</td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>conditionAndAlwayTrueAllow</pre></sub></td>
<td><sub>检查查询条件(WHERE/HAVING子句)中是否包含AND永真条件</sub></td>
<td><sub>false</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub> 
实际条件如果稍微复杂，可能就判断不出来了，例如： </sub></p>
<p><sub>update t1 set id = 1 where 1=1 and (1 =1 or id =2) ; </sub></p> 
<p><sub>select * from t1 having id =1 and (1 =1 or id =2) ;  </sub></p>
<p><sub>值为true时，允许语句中查询条件(WHERE/HAVING子句)中包含AND永真条件。值为false时，不允许语句中查询条件(WHERE/HAVING子句)中包含AND永真条件
</sub></p></td>
<td>
<p><sub>select * from t1  where id = 567 and 1 = 1;   </sub></p>
<p><sub>update t1 set id = 1 where 1=1 and 1=1;   </sub></p>
<p><sub>select * from t3  where id = 567 and k like ‘%’;   </sub></p>
<p><sub>select * from t1 having id =1 and 1=1;  
</td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>conditionLikeTrueAllow</pre></sub></td>
<td><sub>检查查询条件(WHERE/HAVING子句)中是否包含LIKE永真条件</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub> 
单独使用并不会拦截。
conditionLikeTrueAllow为false的时候才会把like ‘%’当成永真条件配合其他参数（比如conditionAndAlwayTrueAllow）使用  
值为true时，语句中查询条件(WHERE/HAVING子句)中包含LIKE永真条件，不判断为永真条件。值为false时，语句中查询条件(WHERE/HAVING子句)中包含LIKE永真条件，判断为永真条件
</sub></p></td>
<td>
<p><sub>select * from t3  where id = 5 and k like '%'; </sub></p> 
<p><sub>select * from t1 having id =1 and k like '%';  </sub></p>
</td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>selectLimit</pre></sub></td>
<td><sub>配置最大返回行数</sub></td>
<td><sub>-1</sub></td>
<td><p><sub>-1 不设置</sub></p></td>
<td><p><sub> 
配置最大返回行数，如果select语句没有指定最大返回行数，会自动修改selct添加返回限制
</sub></p></td>
<td><sub>
</sub></td>
<td><sub>不支持，dble中不可用</sub></td>
<td><sub>不支持，dble中不可用</sub></td>
</tr>
</tbody>
</table>
2.select into 参数
<table >
<tr >
<th >
<div><sub>配置名称</sub></div>
</th>
<th >
<div><strong><sub>描述</sub></strong></div>
</th>
<th >
<div><strong><sub>默认值</sub></strong></div>
</th>
<th >
<div><strong><sub>可选项</sub></strong></div>
</th>
<th >
<div><strong><sub>详细作用原理或应用</sub></strong></div>
</th>
<th >
<div><strong><sub>命中黑名单sql样例</sub></strong></div>
</th>
<th >
<div><strong><sub>分库分表支持程度</sub></strong></div>
</th>
<th >
<div><sub>读写分离支持程度</sub></div>
</th>
</tr>
<tbody >
<tr>
<td><sub><pre>selectIntoAllow</pre></sub></td>
<td><sub>SELECT查询中是否允许INTO语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>
值为true时，允许select into语句。值为false时，不允许select into语句
</sub></p></td>
<td><sub>select * into @myvar from t1;  </sub></p>
<p><sub>select * from t1 into @myvar for update;  </sub></p>
<p><sub>select id, data into @x, @y from test.t1 limit 1;</sub></p>
</td>
<td><sub>不支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>selectIntoOutfileAllow</pre></sub></td>
<td><sub>当outfile子句不是最外层的sql时，SELECT ... INTO OUTFILE 是否允许</sub></td>
<td><sub>false</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>满足outfile子句不是最外层的sql时，
值为true时，允许SELECT ... INTO OUTFILE语句。值为false时，不允许SELECT ... INTO OUTFILE语句
</sub></p></td>
<td>
<sub>
select * from t1 where id in(select id into outfile '/exportdata/customers.txt' fields terminated by ',' optionally enclosed by '"' lines terminated by '\n' from t1);
</sub>
<p><sub>这个sql并不符合sql语法，是基于druid逻辑构造出来的sql，所以无实际意义</sub></p></td>
<td><sub>不支持，无意义</sub></td>
<td><sub>不支持，无意义</sub></td>
</tr>
</tbody>
</table>
3.AlwayTrue条件（规则复杂，理论上都可以使用，但规则有点奇葩，一般来说，无论开关都无影响，建议保持默认值）
<table >
<tr >
<th >
<div><sub>配置名称</sub></div>
</th>
<th >
<div><strong><sub>描述</sub></strong></div>
</th>
<th >
<div><strong><sub>默认值</sub></strong></div>
</th>
<th >
<div><strong><sub>可选项</sub></strong></div>
</th>
<th >
<div><strong><sub>详细作用原理或应用</sub></strong></div>
</th>
<th >
<div><strong><sub>命中黑名单sql样例</sub></strong></div>
</th>
<th >
<div><strong><sub>分库分表支持程度</sub></strong></div>
</th>
<th >
<div><sub>读写分离支持程度</sub></div>
</th>
</tr>
<tbody >
<tr>
<td><sub><pre>selectWhereAlwayTrueCheck</pre></sub></td>
<td><sub>检查SELECT语句的WHERE子句是否为一个AlwayTrue条件</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>AlwayTrue条件规则复杂 ： </sub></p> 
<p><sub>1.where条件存在恒真  </sub></p>
<p><sub>2.sql以注释结尾  </sub></p>
<p><sub>3.条件部分不是简单SQL（单个条件、含有简单数值对等或大小比较、直接是真假值的表达式等）  </sub></p>
<p><sub>比如update t1 set idd =1 where id = id 是恒真，但不命中条件2和3</sub></p>
<p><sub>值为true时，不允许满足以上条件的sql执行。值为false时，允许满足以上条件的sql执行
</sub></p></td>
<td><sub>select id from t1 where id =1  union select 1 /*!dble:sql=select 1 from account */;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>selectHavingAlwayTrueCheck</pre></sub></td>
<td><sub>检查SELECT语句的HAVING子句是否为一个AlwayTrue条件</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>AlwayTrue条件含义详见selectWhereAlwayTrueCheck</sub></p>
<p><sub>值为true时，不允许满足以上条件的sql执行。值为false时，允许满足以上条件的sql执行
</sub></p></td>
<td><sub>select * from t1 having id = 1 or 1=1 /*!dble:sql=select 1 from account */;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>deleteWhereAlwayTrueCheck</pre></sub></td>
<td><sub>检查DELETE语句的WHERE子句是否为一个AlwayTrue条件</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>AlwayTrue条件含义详见selectWhereAlwayTrueCheck</sub></p>
<p><sub>值为true时，不允许满足以上条件的sql执行。值为false时，允许满足以上条件的sql执行
</sub></p></td>
<td><sub>delete from t1 where id = 1 or 1=1 /*!dble:sql=select 1 from account */;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>updateWhereAlayTrueCheck</pre></sub></td>
<td><sub>检查UPDATE语句的WHERE子句是否为一个AlwayTrue条件</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>AlwayTrue条件含义详见selectWhereAlwayTrueCheck</sub></p>
<p><sub>值为true时，不允许满足以上条件的sql执行。值为false时，允许满足以上条件的sql执行
</sub></p></td>
<td><sub>update t1 set idd =1 where id = id or  1=1 /*!dble:sql=select 1 from account */</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
</tbody>
</table>
4.复杂规则设置（规则复杂，理论上都可以使用，但规则有点奇葩，一般来说，无论开关都无影响，建议保持默认值）
<table >
<tr >
<th >
<div><sub>配置名称</sub></div>
</th>
<th >
<div><strong><sub>描述</sub></strong></div>
</th>
<th >
<div><strong><sub>默认值</sub></strong></div>
</th>
<th >
<div><strong><sub>可选项</sub></strong></div>
</th>
<th >
<div><strong><sub>详细作用原理或应用</sub></strong></div>
</th>
<th >
<div><strong><sub>命中黑名单sql样例</sub></strong></div>
</th>
<th >
<div><strong><sub>分库分表支持程度</sub></strong></div>
</th>
<th >
<div><sub>读写分离支持程度</sub></div>
</th>
</tr>
<tbody >
<tr>
<td><sub><pre>caseConditionConstAllow</pre></sub></td>
<td><sub>是否允许复杂查询中外部是一个常量</sub></td>
<td><sub>false</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>具体条件如下  </sub></p>
<p><sub>1.子查询是简单case类型select语句</sub></p>
<p><sub>2.子查询外部是常量 </sub></p>
<p><sub>值为true时，允许子查询外部对应的是常量。值为false时，子查询外部对应的是常量那么就在SQL检查的时候抛出异常
</sub></p></td>
<td><sub>select id from t1 where id =1  union select 1 /*!dble:sql=select 1 from account */;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
<tr>
<td><sub><pre>selectUnionCheck</pre></sub></td>
<td><sub>是否进行union check</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>检测SELECT UNION，具体条件如下  </sub></p>
<p><sub>1.left sql需包含from条件</sub></p>
<p><sub>2.left sql有where条件</sub></p>
<p><sub>3.right sql 没有from条件</sub></p>
<p><sub>4.操作符为UNION 或者UNION ALL 或者UNION DISTINCT</sub></p>
<p><sub>5.sql结尾有注释  </sub></p>
<p><sub>值为true时，不允许UNION语句。值为false时，允许UNION语句
</sub></p></td>
<td><sub>select id from t1 where id =1  union select 1 /*!dble:sql=select 1 from account */;</sub></td>
<td><sub>支持</sub></td>
<td><sub>支持</sub></td>
</tr>
</tbody>
</table>
5.禁用对象检测配置
<table >
<tr >
<th >
<div><sub>配置名称</sub></div>
</th>
<th >
<div><strong><sub>描述</sub></strong></div>
</th>
<th >
<div><strong><sub>默认值</sub></strong></div>
</th>
<th >
<div><strong><sub>可选项</sub></strong></div>
</th>
<th >
<div><strong><sub>详细作用原理或应用</sub></strong></div>
</th>
<th >
<div><sub>备注</sub></div>
</th>
</tr>
<tbody >
<tr>
<td><sub><pre>tableCheck</pre></sub></td>
<td><sub>检测是否使用了禁用的表</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>这个需要配合drui的配置模式使用，在dble此功能无法被使用</sub></p></td>
<td><sub>druid使用，dble不具有使用意义</sub></td>
</tr>
<tr>
<td><sub><pre>functionCheck</pre></sub></td>
<td><sub>检测是否使用了禁用的函数</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>这个需要配合drui的配置模式使用，在dble此功能无法被使用</sub></p></td>
<td><sub>druid使用，dble不具有使用意义</sub></td>
</tr>
<tr>
<td><sub><pre>objectCheck</pre></sub></td>
<td><sub>检测是否使用了“禁用对象”</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>这个需要配合drui的配置模式使用，在dble此功能无法被使用</sub></p></td>
<td><sub>druid使用，dble不具有使用意义</sub></td>
</tr>
<tr>
<td><sub><pre>variantCheck</pre></sub></td>
<td><sub>检测是否使用了“禁用的变量”</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>这个需要配合drui的配置模式使用，在dble此功能无法被使用</sub></p></td>
<td><sub>druid使用，dble不具有使用意义</sub></td>
</tr>
<tr>
<td><sub><pre>readOnlyTables</pre></sub></td>
<td><sub>指定的表只读，不能够在SELECT INTO、DELETE、UPDATE、INSERT、MERGE中作为"被修改表"出现</sub></td>
<td><sub>空</sub></td>
<td><p><sub>需要指定表</sub></p></td>
<td><p><sub>指定的表只读后，在SELECT INTO、DELETE、UPDATE、INSERT、MERGE语句中出现会抛出异常返回错误信息</sub></p></td>
<td><sub>druid使用，dble不具有使用意义，不能配置该参数</sub></td>
</tr>functionCheck
<tr>
<td><sub><pre>schemaCheck</pre></sub></td>
<td><sub>检测是否使用了禁用的Schema</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>这个需要配合drui的配置模式使用，在dble此功能无法被使用</sub></p></td>
<td><sub>druid使用，dble不具有使用意义，不能配置该参数</sub></td>
</tr>
</tbody>
</table>
6.其他规则设置
<table >
<tr >
<th >
<div><sub>配置名称</sub></div>
</th>
<th >
<div><strong><sub>描述</sub></strong></div>
</th>
<th >
<div><strong><sub>默认值</sub></strong></div>
</th>
<th >
<div><strong><sub>可选项</sub></strong></div>
</th>
<th >
<div><strong><sub>详细作用原理或应用</sub></strong></div>
</th>
<th >
<div><sub>备注</sub></div>
</th>
</tr>
<tbody >
<tr>
<td><sub><pre>selectMinusCheck</pre></sub></td>
<td><sub>检测SELECT MINUS</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>值为true时，允许SELECT MINUS语句。值为false时，不允许SELECT  MINUS语句</sub></p></td>
<td><sub>mysql不支持该语法，不具备使用意义</sub></td>
</tr>
<tr>
<td><sub><pre>selectExceptCheck</pre></sub></td>
<td><sub>检测SELECT EXCEPT</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>值为true时，允许except语句。值为false时，不允许except语句</sub></p></td>
<td><sub>mysql不支持该语法，不具备使用意义</sub></td>
</tr>
<tr>
<td><sub><pre>selectIntersectCheck</pre></sub></td>
<td><sub>检测SELECT INTERSECT</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>值为true是，不允许INTERSECT语句，值为false时，允许INTERSECT语句</sub></p></td>
<td><sub>mysql不支持该语法，不具备使用意义</sub></td>
</tr>
<tr>
<td><sub><pre>strictSyntaxCheck</pre></sub></td>
<td><sub>是否进行严格的语法检测</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>Druid SQL Parser在某些场景不能覆盖所有的SQL语法，出现解析SQL出错。
属于调试级别的参数，在正常的使用中不建议更改</sub></p></td>
<td><sub>druid开发者功能，不具备使用意义，保持默认值即可</sub></td>
</tr>
<tr>
<td><sub><pre>minusAllow</pre></sub></td>
<td><sub>是否允许SELECT * FROM A MINUS SELECT * FROM B这样的语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>值为true时，允许MINUS语句。值为false时，不允许MINUS语句</sub></p></td>
<td><sub>mysql不支持该语法，不具备使用意义</sub></td>
</tr>
<tr>
<td><sub><pre>intersectAllow</pre></sub></td>
<td><sub>是否允许SELECT * FROM A INTERSECT SELECT * FROM B这样的语句</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>值为true时，允许intersect语句。值为false时，不允许intersect语句</sub></p></td>
<td><sub>mysql不支持该语法，不具备使用意义</sub></td>
</tr>
<tr>
<td><sub><pre>completeInsertValuesCheck</pre></sub></td>
<td><sub>在dble依赖的1.0.31、1.2.6版本中没有效果</sub></td>
<td><sub>false</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>druid内部函数调用值,不建议修改</sub></p></td>
<td><sub>druid使用，dble不具有使用意义</sub></td>
</tr><tr>
<td><sub><pre>doPrivilegedAllow</pre></sub></td>
<td><sub>druid内部权限控制使用</sub></td>
<td><sub>false</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>druid内部函数调用flag,不建议修改</sub></p></td>
<td><sub>druid使用，dble不具有使用意义</sub></td>
</tr>
<tr>
<td><sub><pre>wrapAllow</pre></sub></td>
<td><sub>是否允许调用Connection/Statement/ResultSet的isWrapFor和unwrap方法</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>druid内部函数调用flag</sub></p></td>
<td><sub>druid连接池功能，dble不具有使用意义</sub></td>
</tr>
<tr>
<td><sub><pre>metadataAllow</pre></sub></td>
<td><sub>是否允许调用Connection.getMetadata方法</sub></td>
<td><sub>true</sub></td>
<td><p><sub>true </sub></p><p><sub>false</sub></p></td>
<td><p><sub>druid内部函数调用flag</sub></p></td>
<td><sub>druid连接池功能，dble不具有使用意义</sub></td>
</tr>



</tbody>
</table>

### 1.3.8 tenant（租户配置）

dble支持两种方式的设置


1. 用户:租户
   这种方式以:分隔开用户和租户，一起作为登录的用户
   如：

   ```shell
   mysql -u用户:租户 -p -h
   ```

   ```java
   DriverManager.getConnection("jdbc:mysql://127.0.0.1:8066", "root2:tenant1", "123456");
   ```

2. JDBC-connectionAttributes
   在`connectionAttributes`中添加tenant指定租户名称
   如：

   ```java
   DriverManager.getConnection("jdbc:mysql://127.0.0.1:8066?connectionAttributes=tenant:tenant1", "root2", "123456");
   ```



*以上两种方式中，若同时设置了1/2两种方式，则采用方式1的配置*

### 1.3.9 whiteIPs（IP白名单）

默认不限制，值为IP，多个用逗号隔开

格式：

支持用户输入多ip，如192.168.1.2,192.168.2.22     
支持用户输入IP段，如192.168.1.10-192.168.1.100       
支持用户输入通配符，如192.168.1.%      
支持用户输入IP/CIDR格式，如192.168.1.1/20     

*以上格式同样适合IPV4/IPV6*

注：

* 管理员用户一旦配置该项，默认允许本机（127.0.0.1、0:0:0:0:0:0:0:1）登陆
* IPV6格式中不支持IPv4映射

### 1.3.10 完整例子

```  
<?xml version="1.0" encoding="UTF-8"?>
<dble:user xmlns:dble="http://dble.cloud/">
    <managerUser name="man1" password="654321" whiteIPs="127.0.0.1,0:0:0:0:0:0:0:1" readOnly="false"/>
    <managerUser name="user" usingDecrypt="true" readOnly="true" password="AqEkFEuIFAX6g2TJQnp4cJ2r7Yc0Z4/KBsZqKhT8qSz18Aj91e8lxO49BKQElC6OFfW4c38pCYa8QGFTub7pnw==" />

    <shardingUser name="root" password="123456" schemas="testdb" readOnly="false" blacklist="blacklist1" maxCon="20"/>
    <shardingUser name="root2" password="123456" schemas="testdb,testdb2" maxCon="20" tenant="tenant1">
        <privileges check="true">
            <schema name="testdb" dml="0110">
                <table name="tb01" dml="0000"/>
                <table name="tb02" dml="1111"/>
            </schema>
        </privileges>
    </shardingUser>
    <!--rwSplitUser not work for now-->
    <rwSplitUser name="rwsu1" password="123456" dbGroup="dbGroup1" blacklist="blacklist1"
                 maxCon="20"/>
                 
    <analysisUser name="analysisUser" password="123456" dbGroup="dbGroup3" maxCon="20"/>
    
    <hybridTAUser name="hysu1" password="111111" schemas="testdb3" maxCon="20"/>
    <hybridTAUser name="hysu2" password="111111" schemas="testdb3" maxCon="20" blacklist="blacklist1" tenant="tenant2">
        <privileges check="true">
            <schema name="testdb3" dml="0110">
                <table name="tb_global1" dml="0000"/>
                <table name="tb_global2" dml="1111"/>
            </schema>
        </privileges>
    </hybridTAUser>

    <blacklist name="blacklist1">
        <property name="selectAllow">true</property>
    </blacklist>
</dble:user>

```  
